# Kubernetes

**What is Kubernetes?**  
Also known as K8s, it is an open-source system for automating the deployment, management, and scaling of containerized applications.

**What is a Container?**  
- A way to package an application with all the necessary dependencies and configurations.
- It can be easily shared.
- It makes deployment and development efficient.

**What is Container Orchestration?**  
Container orchestration is a method for managing the deployment, scaling, and operation of containerized applications. Containers package an application and its dependencies together, making it easier to deploy consistently across different environments. However, managing containers at scale—especially when dealing with many instances or across multiple machines—can be complex. Container orchestration tools help automate and streamline this process.

Example: The master guides the players in orchestration. Similarly, Kubernetes guides the containers in containerized applications.

**Kubernetes Architecture**  

When you deploy Kubernetes, you get a cluster.  
Two important parts are: Master (Control Plane) and Worker nodes.

- **Nodes (Minions)** - A node is essentially a server where you install container-based applications.
- **Cluster** - A group of nodes is called a cluster.
- **Master** - This is Kubernetes, used to manage the nodes. The Kubernetes Master will have an API Server that connects to all the worker nodes using an agent called Kubelet.

**What is a Pod?**  
A single instance of a running process in a cluster. It can run one or more containers and share the same resources.

**Components of Kubernetes:**

The Kubernetes Master will have:
1. **API Server** - Provides the interface called Kubectl to interact with the worker nodes.
2. **Scheduler** - Assigns nodes to newly created pods.
3. **ETCD** - A key-value store containing all cluster data.
4. **Controller Manager** - Responsible for managing the state of the cluster.

Worker Nodes will have:
1. **Kubelet** - An agent that ensures containers are running in pods.
2. **Container-based app in an isolated environment (POD)** - Containers run in a pod.
3. **kube-proxy** - Maintains network rules for communication with pods.
4. **container-runtime** - A tool responsible for running containers.

**Features of Kubernetes:**
- Container Orchestration
- Scalability
- Load Balancing
- High Availability
- Rollouts & Rollbacks
- Lifecycle Management
- Declarative Model
- Persistent Storage
- Resilience and Self-Healing

Sample YAML Config file:

```yml
apiVersion: v1
kind: Pod 
metadata:
  name: my-pod 
spec:
  containers:
    - name: my-container 
      image: nginx
      ports:
      - containerPort: 80
```

### Installation of K8s on Linux

Installation Guide [Official Documentation](https://kubernetes.io/docs/tasks/tools/install-kubectl-linux/)

First, you need to install Kubectl. In this example, we are using a RedHat-based distribution for installation.

Run the following command to update the repository on the RedHat server:

```bash
cat <<EOF | sudo tee /etc/yum.repos.d/kubernetes.repo
[kubernetes]
name=Kubernetes
baseurl=https://pkgs.k8s.io/core:/stable:/v1.30/rpm/
enabled=1
gpgcheck=1
gpgkey=https://pkgs.k8s.io/core:/stable:/v1.30/rpm/repodata/repomd.xml.key
EOF
```
Once the repository is updated, you can install kubectl:

```bash
sudo yum install -y kubectl
```
Verify the installation:

```bash
# kubectl version --client
Client Version: v1.28.4
Kustomize Version: 5.0.4-0.20230601165947-6ce0bf390ce3
#
```
The next step is to install **MiniKube** [Official Documentation](https://minikube.sigs.k8s.io/docs/start/?arch=%2Flinux%2Farm64%2Fstable%2Frpm+package) (Minikube is a local Kubernetes solution that uses a single-node cluster in which both master and worker nodes exist, for practice purposes).

```bash
curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-latest.aarch64.rpm
sudo rpm -Uvh minikube-latest.aarch64.rpm
```

Verify the installation:

```bash
# minikube start
```

When Minikube is installed, by default, it picks the **docker** driver. However, the **docker** driver should not be used with **root** privileges. Therefore, it gives an error when you run `minikube start`. You can create another user and add it to the docker group to run Minikube.

We already have a user named **paul**. Just switch to that user, add the user **paul** to the **docker** group, and then run Minikube:

```bash
# su - paul
$ sudo usermod -aG docker $USER && newgrp docker
$ id paul
uid=1000 (paul) gid=976(docker) groups=976 (docker), 10(wheel), 1000 (paul) context=unconfined u:unconfined
u: unconfined_r:unconfined_t: 50-s0:cO.c1023
$ systemctl start docker
$ minikube start
$ minikube status
minikube
type: Control Plane 
host: Running 
kubelet: Running 
apiserver: Running 
kubeconfig: Configured
$ kubectl cluster-info
Kubernetes control plane is running at https://192.168.49.2:8443
CoreDNS is running at https://192.168.49.2:8443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy
```

When you deploy Kubernetes, you get a master node (Control Plane) and worker nodes. Using Minikube, we are running both master and worker nodes on one machine locally.

Now that everything is in place, we can run applications in Kubernetes. In Kubernetes, a pod is the smallest unit, and containers run inside the pod.

### Deployment of an App in K8s

We have installed and set up Kubernetes on a MacBook too, using the official documentation. The following example is being deployed from a MacBook.

You can use the pre-existing Docker image from DockerHub for the deployment:

```bash
# kubectl create deployment my-nginx --image=nginx:latest
deployment.apps/my-nginx created
# kubectl get deployments
NAME     READY UP-TO-DATE  AVAILABLE AGE
my-nginx 1/1   1           1         23s
# kubectl get pods
NAME                      READY STATUS  RESTARTS  AGE
my-nginx-86d74cfc8f-ltq54 1/1   running 0         52s
# minikube dashboard
```
`minikube dashboard` opens the dashboard window, where you can visually get the details of the deployments, pods, etc.

Now Nginx is deployed inside the container, which is inside the pod. Nginx usually uses port 80 for access. However, the pod is in an isolated environment, and we cannot directly access the application inside the pod using port 80. Similar to port-binding in Docker, you need to use a service object in Kubernetes to make the container application accessible via the internet.

```bash
# kubectl expose deployment my-nginx --port=80 --type=LoadBalancer
service/my-nginx exposed
# kubectl get services
NAME        TYPE          CLUSTER-IP      EXTERNAL-IP PORT(S)       AGE
kubernetes  ClusterIP     10.96.0.1       <none>      443/TCP       5d18h
my-nginx    LoadBalancer  10.104.234.173  <pending>   80:31132/TCP  125s
# minikube service my-nginx
```

**Commands Overview:**

- **`minikube start/delete`**: Starts or deletes a Minikube cluster.
- **`minikube status`**: Displays the status of the Minikube cluster.
- **`minikube dashboard`**: Opens the Kubernetes dashboard for visual management of resources.

- **`kubectl create deployment my-app --image=link`**: Creates a deployment named `my-app` using the specified Docker image.
- **`kubectl get deployments`**: Lists all deployments in the current namespace.
- **`kubectl get pods`**: Lists all pods in the current namespace.
- **`kubectl delete deployment my-app`**: Deletes the deployment named `my-app`.

- **`kubectl expose deployment my-app --type=LoadBalancer --port=80`**: Exposes the `my-app` deployment as a service with a LoadBalancer on port 80.
- **`minikube service my-app`**: Opens a web browser to access the service named `my-app` in Minikube.
- **`kubectl get services`**: Lists all services in the current namespace.

**Kubernetes Basic Modules:**
1. Create a Kubernetes cluster
2. Deploy an app
3. Explore your app
4. Expose your app publicly
5. Scale up your app
6. Update your app

### Create a Web App Demo Project

First, you need to install Node.js on your system. We will use Visual Studio Code to edit the files. Install it if you don't already have it.

Open VS Code, navigate to the folder where you want to create your project, right-click, and open the Integrated Terminal. Run the following commands to create a basic test React app:

```bash
% node -v
v20.9.0
% npx create-react-app testapp
% cd testapp
$ npm start
```

Once you run `npx create-react-app testapp`, it will create a **testapp** folder and generate all the necessary files to run the test React app.

**Creating Dockerfile**

In the **testapp** folder, you can delete the **node_modules** directory, as we don't want it to be copied while creating an image from the Dockerfile. We will use `RUN npm install` in the Dockerfile to get the node modules.

Now create a new file inside the **testapp** folder, named `Dockerfile`.

Dockerfile:
```Dockerfile
FROM node

WORKDIR /myapp

COPY . .

RUN npm install

EXPOSE 3000

CMD ["npm", "start"]
```

**Creating and Pushing Docker Image**

You can't use a local image for deployment in Kubernetes; you need to push the image to a repository and pull it from there.

Create a repository on Docker Hub, for example, `philippaul/webapp-demo`:

```bash
% cd testapp
% docker ps
% docker build -t philippaul/webapp-demo:02 .
% docker images
REPOSITORY              TAG IMAGE ID      CREATED         SIZE
philippaul/webapp-demo  02  c806ab1654c3  17 seconds ago  1.4GB
% docker login
% docker push philippaul/webapp-demo:02
```

- Navigate to the **testapp** folder where you have all the required files and `Dockerfile`.
- Build an image with the tag matching your repository using `docker build -t <repo_name> .`.
- Log in to Docker Hub using `docker login`.
- Push the image with its name and tag using `docker push <image_name:tag>`.

### Deployment of Our Web App in K8s

Now, using the image we have created, deploy a web app in the Kubernetes cluster:

```bash
% minikube start
% minikube status
% kubectl create deployment my-webapp --image=philippaul/webapp-demo:02
deployment.apps/my-webapp created
% kubectl get deployments
NAME        READY UP-TO-DATE  AVAILABLE AGE
my-webapp   1/1   1           1         23s
% kubectl get pods
NAME                       READY STATUS  RESTARTS  AGE
my-webapp-66d74cfc9f-ltq69 1/1   running 0         52s
% kubectl describe pods
% kubectl logs my-webapp-66d74cfc9f-ltq69
```

- Check the status using `minikube status`. If not started, start it using `minikube start`.
- Create a deployment using `kubectl create deployment <app_name> --image=<image_name:tag>`.
- Check the deployments using `kubectl get deployments`.
- Check the pods using `kubectl get pods`.
- To get detailed information about the pods, use `kubectl describe pods`.
- To get logs from a particular pod, use `kubectl logs <pod_name>`.

**Exposing Port Using Service in K8s**

```bash
% kubectl expose deployment my-webapp --type=LoadBalancer --port=3000
service/my-webapp exposed
% kubectl get services
NAME        TYPE          CLUSTER-IP      EXTERNAL-IP PORT(S)         AGE
my-webapp   LoadBalancer  10.108.38.25    <pending>   3000:30952/TCP  13s
% minikube service my-webapp
```

After you expose the application inside the container to the internet, you will be able to access the web app using `localhost:3000` or the link provided in the output after executing `minikube service <appname>`.

### Updating Our App in K8s Rollout

You have made some changes in the code and want to deploy those updates to the application. First, you need to build a new image and push it to Docker Hub:

```bash
% docker build -t philippaul/webapp-demo:05 .
% docker push philippaul/webapp-demo:05
```

Currently, our application is up and running in a live environment. We want to update the application without downtime. Kubernetes handles this; you just need to point the deployment to the new image.

```bash
% kubectl get deployments
NAME      READY UP-TO-DATE  AVAILABLE AGE
my-webapp 1/1   1           1         171m

% kubectl get pods
NAME                        READY STATUS  RESTARTS  AGE
my-webapp-848c799c9b-ds9td  1/1   Running 0         23m

% kubectl set image deployment my-webapp webapp-demo=philippaul/webapp-demo:05
deployment.apps/my-webapp image updated

% kubectl get pods
NAME                        READY STATUS            RESTARTS  AGE
my-webapp-7c7b89cf99-rdnb4  0/1   ContainerCreating 0         8s
my-webapp-848c799c9b-ds9td  1/1   Running           0         26m

% kubectl get pods
NAME                        READY STATUS        RESTARTS  AGE
my-webapp-7c7b89cf99-rdnb4  1/1   Running       0         42s
my-webapp-848c799c9b-ds9td  1/1   Terminating   0         26m

% kubectl get pods
NAME                        READY STATUS        RESTARTS  AGE
my-webapp-7c7b89cf99-rdnb4  1/1   Running       0         50s
```

- To point the deployment to the new image, use `kubectl set image deployment <deployment_name> <container_name>=<new_image_name:tag>`.
- As soon as you point the deployment to the new image, Kubernetes starts deploying a new pod and terminates the old one. The old pod is not terminated until the new pod is ready, ensuring no downtime. You can monitor this process using `kubectl get pods`.
- This is how you roll out changes in Kubernetes in a live environment.
- You can switch to any version of the pods by pointing the image to the desired version. You just need to have the image versions available in the Docker Hub repository.

### Rollback of Project in K8s

In case you point the deployment to the wrong image or an image that doesn't exist, Kubernetes will update the image, but when it tries to pull the image from the Docker repository and gets stuck in the `ImagePullBackOff` state.

```bash
% kubectl set image deployment my-webapp webapp-demo=philippaul/webapp-demo:05
deployment.apps/my-webapp image updated

% kubectl get pods
NAME                        READY STATUS            RESTARTS  AGE
my-webapp-6d6f889468-w91c9  0/1   ImagePullBackOff  0         8s
my-webapp-7c7b89cf99-rdnb4  1/1   Running           0         3m

% kubectl rollout status deployment my-webapp
Waiting for deployment "my-webapp" rollout to finish: 1 old replica is pending termination...
```

To check the rollout status, use `kubectl rollout status deployment <deployment_name>`. In the example above, it is waiting for the rollout but will not finish since there is no such image to pull and complete the deployment.

To roll back the deployment, use `kubectl rollout undo deployment <deployment_name>`:

```bash
% kubectl rollout undo deployment my-webapp
deployment.apps/my-webapp rolled back

% kubectl get pods
NAME                        READY STATUS     RESTARTS  AGE
my-webapp-7c7b89cf99-rdnb4  1/1   Running    0         8m
```
